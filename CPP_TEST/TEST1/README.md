# Test 1 Discussion Questions

- **Question:** Walk through the full build lifecycle of this project: what does the preprocessor do with the headers in `include/`, what transformations occur during compilation of `src/Line.cpp`, and how does the linker combine the resulting objects into a runnable program?
	**Answer:** The preprocessor expands `#include` directives by inlining the contents of `include/Line.h` into each translation unit, applies conditional compilation, and macro substitutions. The compiler then translates each `.cpp` file—after preprocessing—into assembly, optimizing syntax trees and emitting an object file (`Line.o`, `main.o`). The linker resolves symbol references between those objects, ensures the single definition of `LineSample::instance_count`, pulls in runtime libraries, and produces a final executable. For extra depth, show how `#include "Line.h"` literally pastes the header text into `Line.cpp`, or how `#define MAX 10` replaces every `MAX` token before compilation. Contrast static linking (object code merged into the exe) with dynamic linking (symbols resolved at runtime against shared libraries), and discuss trade-offs in binary size and update cadence.
- **Question:** Suppose you split `LineSample` across multiple headers that depend on each other. How would you detect and resolve a circular dependency between those headers while keeping the code testable?
	**Answer:** Circularity shows up as repeated inclusion or incomplete type errors during compilation. Use include guards/`#pragma once` to catch multiple inclusion, forward declare classes where only pointers or references are needed, and move shared definitions into a neutral header or implementation file. If concrete implementations must interact, extract interfaces (pure virtual classes) into lightweight headers so tests can mock dependencies without pulling the entire cycle.
- **Question:** `LineSample::instance_count` lives in static storage, the local `print_call_count` in `PrintLine()` persists across calls, and `heap_buffer` is allocated with `new`. Map each of these to the C++ memory address spaces (static/data, stack, heap) and explain the lifetime guarantees and cleanup responsibilities involved.
	**Answer:** `instance_count` resides in static storage (data segment), exists from program start to termination, and the runtime handles initialization and cleanup; only logical invariants need manual care. `print_call_count` is a function-local static, also stored in the data segment, initialized once on first entry and never destroyed until process exit. `heap_buffer` lives on the heap, persists until `delete[]` is called, and leaks if cleanup is skipped, so the caller must pair allocations with deallocations (or replace with RAII containers like `std::vector`). For more credit, point out that static and global variables are zero-initialized before `main`, while dynamic initialization runs before first use. Note that the compiled machine code resides in the text segment of the binary loaded into read-only memory pages. Discuss `static` keyword use cases (internal linkage, function-lifetime singletons, file-scope helpers) and sketch how a multithreaded address space still shares text/data segments but provides each thread with its own stack while sharing the heap.
- **Question:** Consider the simple template utility `Line::GetLastValue` in `include/Line.h`. How does template instantiation work here, and what constraints would you place on `T` to prevent misuse?
	**Answer:** Because the definition is in the header, the compiler instantiates `GetLastValue<T>` whenever a translation unit uses it with a concrete type, substituting that type through the function body. Instantiation succeeds for types that provide `values.back()` (i.e., `std::vector`-like containers). To constrain `T`, you could require `std::vector<T>` specifically, document the expectation, or use concepts (`requires std::ranges::random_access_range`) so invalid types fail with a clear diagnostic. To go deeper, walk through class templates (e.g., `template<class T> class LineBuffer`) and template aliases, highlight partial and explicit specialization for edge cases, and explain how template metaprogramming enables compile-time algorithms (even Turing complete via recursion on integral constants). Include examples of using templates to build policy-based designs, CRTP patterns, or type-safe factories.
- **Question:** Identify the spots in `src/Line.cpp` where unnecessary copies occur (constructor, `SplitVector`, `GetTop10Percent`). What refactors would you apply (e.g., `std::move`, pass-by-const-reference, `std::span`) to reduce allocations while keeping behavior unchanged?
	**Answer:** The constructor takes `std::vector<int>` by value, forcing a copy; change the signature to `const std::vector<int>&` or `std::vector<int>&&` with `std::move` to reuse storage. `SplitVector` returns two vectors by value after copying subranges; consider returning `std::pair<std::span<const int>, std::span<const int>>` or moving data out if ownership can transfer. `GetTop10Percent` duplicates `line_vector` into `sorted_vector`; sorting in place (if mutation acceptable) or using partial algorithms (`std::nth_element`) reduces copying. Applying move semantics when returning large temporaries also avoids redundant allocations. To push the discussion further, define lvalues vs rvalues (named objects with stable addresses versus temporaries) and show how move constructors/assignments exploit rvalue references (`LineSample(LineSample&& other) noexcept`) to steal resources safely while leaving the source in a valid but unspecified state.
